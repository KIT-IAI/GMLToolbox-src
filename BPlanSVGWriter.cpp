#include "StdAfx.h"

#include <string>
#include <map>
#include <sstream>

#include "Convert.h"
#include "BPlan.h"
#include "BPlanObjekt.h"
#include "Geometrie.h"
#include "Includes.h"

#include ".\BPlanSVGWriter.h"
#using <mscorlib.dll>

///////////////////////////////////////////////////////////////////////////////
//  BPlanSVGWriter															 //
//  Visualisierung eines BPlan über SVG										 //
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//  Konstruktor / Destruktor												 //
///////////////////////////////////////////////////////////////////////////////
BPlanSVGWriter::BPlanSVGWriter ( BLeitplanViewer * pBLeitplanViewerP )
{
	pBLeitplanViewer = pBLeitplanViewerP;

}
BPlanSVGWriter::~BPlanSVGWriter()
{

}

///////////////////////////////////////////////////////////////////////////////
//  SVG-schreiben															 //
///////////////////////////////////////////////////////////////////////////////
int BPlanSVGWriter::write ( std::string fileNameP,  BLeitPlan * pBPlanP, PlanBereich * pBPlanEbeneP )
{
	System::String * fileName;
	System::String * STR;
	System::String * STR_X;
	System::String * STR_Y;
	string           bplanGmlKlassenName;
	string			 temp, temp1;
	double			 _swX, _swY, _noX, _noY;
	int				 i, objAnz;

	vector<PlanObjekt*> vPlanObjekte;


	pBLeitplanViewer->getBoundingBox ( _swX, _swY, _noX, _noY );
	swX = _swX;
	swY = _swY;
	noX = _noX;
	noY = _noY;

	temp = pBLeitplanViewer->getSystemFolder ();
	temp1 = temp + "PolygonStyle.css";
	svgStylesheetDatei = QuConvert::ToString ( temp1 );

	temp1 = temp + "Defines.svg";
	svgDefinesDatei =  QuConvert::ToString ( temp1 );

	fileName = QuConvert::ToString ( fileNameP );

	System::Text::UTF8Encoding * utf8	= new UTF8Encoding();
	writer								= new XmlTextWriter( fileName, utf8);

	writer->Formatting = Formatting::Indented;
	writer->WriteStartDocument(true);

	STR = String::Concat ( "href =\"" , svgStylesheetDatei, "\" type=\"text/css\"" );
	writer->WriteProcessingInstruction ( S"xml-stylesheet", STR );
	writer->WriteDocType ( "svg", "-//W3C//DTD SVG 1.1//EN",  "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11-flat-20030114.dtd", NULL );
	writer->WriteComment("Generated by: FZK-BPlanGML-SVG Viewer");

    writer->WriteStartElement("svg ");

	writer->WriteAttributeString("xmlns:gml",   "http://www.opengis.net/gml");
	writer->WriteAttributeString("xmlns:xlink",	"http://www.w3.org/1999/xlink");
	writer->WriteAttributeString("xmlns:xsi",	"http://www.w3.org/2001/XMLSchema-instance");
//	writer->WriteAttributeString("xmlns:xplan",	"http://www.xplanung.de/bplangml");
//	writer->WriteAttributeString("xmlns:wfs",	"http://www.opengis.net/wfs");

	writer->WriteAttributeString("width", "100%" );
	writer->WriteAttributeString("height", "100%" );

	STR_X = XmlConvert::ToString ( noX - swX );
	STR_Y = XmlConvert::ToString ( noY - swY );
	STR = System::String::Concat( "0.0 0.0 ", STR_X, " ", STR_Y );
	writer->WriteAttributeString ( "viewBox", STR );

	writeFonts();

	writePlanObjekt ( pBPlanP );
	
	objAnz = pBPlanEbeneP->getBPlanObjekte ( vPlanObjekte, false );

	for ( i = 0; i < objAnz; i++ )
	{
		PlanObjekt * pPlanObjekt = vPlanObjekte[i];
		writePlanObjekt ( pPlanObjekt );
	}

	writer->WriteEndElement();

	writer->Flush();
	writer->Close();

	return 0;
}

///////////////////////////////////////////////////////////////////////////////
//  Font-Definitionen schreiben												 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeFonts()
{
	writer->WriteStartElement ( "defs" );

	writer->WriteStartElement ( "font" );
	writer->WriteAttributeString ( "id", "IDfontWWF" );
	writer->WriteAttributeString ( "horiz-adv-x", "100" );

	writer->WriteStartElement ( "font-face" );
	writer->WriteAttributeString ( "font-family", "MyFonts" );
	writer->WriteAttributeString ( "font-weight", "bold" );
	writer->WriteAttributeString ( "units-per-em", "256" );
	writer->WriteEndElement();

	writer->WriteStartElement ( "missing-glyph" );
	writer->WriteEndElement();

	writer->WriteStartElement ( "glyph" );  //  WasserwirtschaftsFlaeche
	writer->WriteAttributeString ( "unicode", "A" );
	writer->WriteAttributeString ( "horiz-adv-x", "100" );
	writer->WriteAttributeString ( "orientation", "h" );
	writer->WriteAttributeString ( "d", "M 0,0 L 100, 0, L 100, 20 A 33, 33, 0, 0, 0, 75, 25 A 33, 33, 0, 0, 1, 50, 30  A 33, 33, 0, 0, 1, 25, 25  A 33, 33, 0, 0, 0, 0, 20 L 0,0" );
	writer->WriteEndElement();


	writer->WriteStartElement ( "glyph" );   //  ImmissionsschutzFlaeche
	writer->WriteAttributeString ( "unicode", "B" );
	writer->WriteAttributeString ( "horiz-adv-x", "150" );
	writer->WriteAttributeString ( "orientation", "h" );
	writer->WriteAttributeString ( "d", "M 0,0 L 100, 0 L 50,50 L 0,0" );
	writer->WriteEndElement();


	writer->WriteStartElement ( "glyph" );   //  LuftreinhalteFlaeche
	writer->WriteAttributeString ( "unicode", "C" );
	writer->WriteAttributeString ( "horiz-adv-x", "150" );
	writer->WriteAttributeString ( "orientation", "h" );
	writer->WriteStartElement ( "path" );
	writer->WriteAttributeString ( "style", "fill:none; stroke:black; stroke-width:5" );
	writer->WriteAttributeString ( "d", "M 0,0 L 100, 0 L 50,50 L 0,0" );
	writer->WriteEndElement();
	writer->WriteEndElement();




	writer->WriteStartElement ( "glyph" );   //  FreiFlaeche
	writer->WriteAttributeString ( "unicode", "D" );
	writer->WriteAttributeString ( "horiz-adv-x", "80" );
	writer->WriteAttributeString ( "orientation", "h" );
	writer->WriteStartElement ( "path" );
	writer->WriteAttributeString ( "style", "fill:none; stroke:black; stroke-width:3" );
	writer->WriteAttributeString ( "d", "M 0,0 L 80, 0 L 40,40 L 0,0" );
	writer->WriteEndElement();
	writer->WriteEndElement();


	writer->WriteEndElement();

	writer->WriteEndElement();
}


///////////////////////////////////////////////////////////////////////////////
//  PlanObjekt schreiben													 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writePlanObjekt ( PlanObjekt * pPlanObjektP )
{
	switch ( pPlanObjektP->getObjektTyp() )
	{
	case FLAECHE: writePlanFlaechenObjekt ( (PlanFlaechenObjekt*)pPlanObjektP ); break;
	case LINIE:   writePlanLinienObjekt ( (PlanLinienObjekt*)pPlanObjektP ); break;
	case PUNKT:   writePlanPunktObjekt ( (PlanPunktObjekt*)pPlanObjektP ); break;
	case PTO:     writePlanPTO ( (PlanPunktObjekt*)pPlanObjektP ); break;
	default: break;
	}
}

///////////////////////////////////////////////////////////////////////////////
//  Flächenobjekt schreiben													 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writePlanFlaechenObjekt ( PlanFlaechenObjekt * pPlanObjektP )
{
	string objektName;
	int    i;

	objektName = pPlanObjektP->getKlassenName();

	for ( i = 0; i < pPlanObjektP->getPolygonAnz(); i++ )
	{
		Polygon * pPoly = pPlanObjektP->getPolygon ( i );
	
		if ( objektName == "RaeumlicherGeltungsbereich" )
			writeRaeumlicherGeltungsbereich ( pPlanObjektP, pPoly );
		else
		if ( objektName == "SchutzPflegeEntwicklungsFlaeche" )
//			writeFoerderungsFlaeche (  pPlanObjektP, pPoly );
			writeSchutzPflegeEntwicklungsFlaeche ( pPlanObjektP, pPoly );
		else
		if ( objektName == "BaugebietsFlaechenTeil" )
			writeBaugebietsFlaechenTeil (  pPlanObjektP, pPoly );
		else
		if ( objektName == "KennzeichnungFlaeche" )
			writeKennzeichnungsFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "FlaecheMitBesonderemNutzungszweck" )
			writeFlaecheMitBesonderemNutzungszweck (  pPlanObjektP, pPoly );
		else
		if ( objektName == "UeberbaubareGrundstuecksflaeche" )
			writeUeberbaubareGrundstuecksflaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "FoerderungsFlaeche" )
			writeFoerderungsFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "PersGruppenBestimmteFlaeche" )
			writePersGruppenBestimmteFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "TechnikBestimmteFlaeche" )
			writeTechnikBestimmteFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "AbgrabungsFlaeche" )
			writeAbgrabungsFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "BodenschaetzeFlaeche" )
			writeBodenschaetzeFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "AufschuettungsFlaeche" )
			writeAufschuettungsFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "GemeinbedarfsFlaeche" )
			writeGemeinbedarfsFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "SpielSportanlagenFlaeche" )
			writeSpielSportanlagenFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "WaldFlaeche" )
			writeWaldFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "LandwirtschaftsFlaeche" )
			writeLandwirtschaftsFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "GruenFlaeche" )
			writeGruenFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "AnpflanzungBindungErhaltungsFlaeche" )
			writeAnpflanzungBindungErhaltungsFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "SchutzgebietFlaeche" )
			writeSchutzgebietFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "SchutzPflegeEntwicklungsFlaeche" )
			writeSchutzPflegeEntwicklungsFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "DenkmalschutzBereich" )
			writeDenkmalschutzBereich (  pPlanObjektP, pPoly );
		else
		if ( objektName == "Erhaltungsbereich" )
			writeErhaltungsbereich (  pPlanObjektP, pPoly );
		else
		if ( objektName == "DenkmalschutzEnsemble" )
			writeDenkmalschutzEnsemble (  pPlanObjektP, pPoly );
		else
		if ( objektName == "VerEntsorgungsFlaeche" )
			writeVerEntsorgungsFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "LuftverkehrFlaeche" )
			writeLuftverkehrFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "BahnFlaeche" )
			writeBahnFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "VerkehrsFlaeche" )
			writeVerkehrsFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "VerkehrsFlaeche" )
			writeVerkehrsFlaecheBesondererZweckbestimmung (  pPlanObjektP, pPoly );
		else
		if ( objektName == "WasserFlaeche" )
			writeWasserFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "WasserwirtschaftFlaeche" )
			writeWasserwirtschaftsFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "WasserrechtlicheFestsetzungsFlaeche" )
			writeWasserrechtsFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "VorbHochwSchutzFlaeche" )
			writeVorbHochwSchutzFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "ImmissionsschutzFlaeche" )
			writeImmissionsschutzFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "LuftreinhalteFlaeche" )
			writeLuftreinhalteFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "FreiFlaeche" )
			writeFreiFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "WegerechteBelasteteFlaeche" )
			writeWegerechteBelasteteFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "NebenanlagenFlaeche" )
			writeNebenanlagenFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "GemeinschaftsanlagenFlaeche" )
			writeGemeinschaftsanlagenFlaeche (  pPlanObjektP, pPoly );
		else
		if ( objektName == "FlaecheAllgemein" )
			writeFlaecheAllgemein (  pPlanObjektP, pPoly );
		else
		if ( objektName == "Strassenkoerper" )
			writeStrassenkoerper (  pPlanObjektP, pPoly );
		else
		if ( objektName == "AusgleicheFlaeche" )
			writeAusgleichsFlaeche (  pPlanObjektP, pPoly );
		else
		{
			writePolygon ( pPlanObjektP->getGmlId(), pPoly, "normal", NULL, false );
		}
	}

}



///////////////////////////////////////////////////////////////////////////////
//  Linienobjekt schreiben													 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writePlanLinienObjekt ( PlanLinienObjekt * pPlanObjektP )
{
	string objektName;

	objektName = pPlanObjektP->getKlassenName();
	Curve * pCurve = pPlanObjektP->getCurve();

	if ( objektName == "Baulinie" )
//	writePflanzungLinienfoermig( pPlanObjektP, pCurve );
	writeBaulinie ( pPlanObjektP, pCurve );
	else
	if ( objektName == "Baugrenze" )
		writeBaugrenze ( pPlanObjektP, pCurve );
	else
	if ( objektName == "FirstRichtung" )
		writeFirstRichtung ( pPlanObjektP, pCurve );
	else
	if ( objektName == "AnpflanzungBindungErhaltungsLinie" )
		writeAnpflanzungBindungErhaltungsLinie ( pPlanObjektP, pCurve );
	else
	if ( objektName == "StrassenkoerperLinie" )
		writeStrassenkoerperLinie ( pPlanObjektP, pCurve );
	else
	if ( objektName == "LinieAllgemein" )
		writeLinieAllgemein ( pPlanObjektP, pCurve );
	else
	if ( objektName == "VerEntsorgungsleitung" )
		writeVerEntsorgungsleitung ( pPlanObjektP, pCurve );
	else
	if ( objektName == "Strassenbegrenzungslinie" )
		writeStrassenbegrenzungslinie ( pPlanObjektP, pCurve );
	else
	if ( objektName == "BahnLinie" )
		writeBahnLinie ( pPlanObjektP, pCurve );
	else
	if ( objektName == "Einfahrtsbereich" )
		writeEinfahrtsbereich ( pPlanObjektP, pCurve );
	else
	if ( objektName == "BereichOhneEinAusfahrt" )
		writeBereichOhneEinAusfahrt ( pPlanObjektP, pCurve );
	else
		writeCurve (  pPlanObjektP->getGmlId(), pCurve, "normal" );
}
///////////////////////////////////////////////////////////////////////////////
//  Punktobjekt schreiben													 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writePlanPunktObjekt ( PlanPunktObjekt * pPlanObjektP )
{
	string objektName;

	objektName = pPlanObjektP->getKlassenName();
	GeoPoint * pPoint = pPlanObjektP->getPoint();

	if ( objektName == "AnpflanzungBindungErhaltungsMassnahme" )
		writeAnpflanzungBindungErhaltungsMassnahme ( pPlanObjektP, pPoint );
	else
	if ( objektName == "AusgleichsMassnahme" )
		writeAusgleichsMassnahme ( pPlanObjektP, pPoint );
	else
	if ( objektName == "HoehenObjekt" )
		writeHoehenObjekt ( pPlanObjektP, pPoint );
	else
	if ( objektName == "PunktAllgemein" )
		writePunktAllgemein ( pPlanObjektP, pPoint );
	else
	if ( objektName == "DenkmalschutzEinzelanlage" )
		writeDenkmalschutzEinzelanlage ( pPlanObjektP, pPoint );
	else
	if ( objektName == "Einfahrt" )
		writeEinfahrt ( pPlanObjektP, pPoint );
}

///////////////////////////////////////////////////////////////////////////////
//  PTO-Objekt schreiben													 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writePlanPTO ( PlanPunktObjekt * pPlanObjektP )
{

}

///////////////////////////////////////////////////////////////////////////////
//  SVG-Ausgabe eines Polygons												 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writePolygon ( std::string idP, Polygon * pPolygonP, 
			String * class1, String * style1, bool clip1,
			String * class2, String * style2, bool clip2,
			String * class3, String * style3,  bool clip3,
			String * class4, String * style4, bool clip4 )
{
	System::String * STR;
	System::String * STR_Number;
	System::String * id;
	System::String * maskString;
	System::String * pathString;
	string			 stdString;
	Ring		   * pRing;
	double			 sw[2], no[2], dx, dy;
	bool             useMask;
	int				 i;

	id = QuConvert::ToString ( idP );

	//  Clip-path mit der Aussenkontur erstellen

	pRing = pPolygonP->getAussenkontur();
	if ( pRing->getUmlaufsinn() )
		stdString = pRing->getPointsSVG ( swX, noY );
	else
		stdString = pRing->getPointsReverseSVG ( swX, noY );
	pathString = QuConvert::ToString ( stdString );

	STR = String::Concat ( id, "_clip" );
	writer->WriteStartElement ( "clipPath" );
	writer->WriteAttributeString ( "id", STR );

	writer->WriteStartElement ( "path" );
	STR = String::Concat ( id, "_aussen" );
	writer->WriteAttributeString ( "id", STR );
	writer->WriteAttributeString ( "d", pathString );

	writer->WriteEndElement();
	writer->WriteEndElement();

	//  Pfade eventueller Löcher in einen defs-Block schreiben
	if ( pPolygonP->getLochAnz() > 0 )
	{
		writer->WriteStartElement ( "defs" );
	 
		for ( i = 0; i < pPolygonP->getLochAnz(); i++ )
		{
			STR_Number = System::Convert::ToString ( i );

			pRing = pPolygonP->getLoch ( i );
			if ( !pRing->getUmlaufsinn() )
				stdString = pRing->getPointsSVG ( swX, noY );
			else
				stdString = pRing->getPointsReverseSVG ( swX, noY );
			pathString = QuConvert::ToString ( stdString );

			writer->WriteStartElement ( "path" );
			STR = String::Concat ( id, "_hole_", STR_Number );
			writer->WriteAttributeString ( "id", STR );
			writer->WriteAttributeString ( "d", pathString );
			writer->WriteEndElement();
		}
		writer->WriteEndElement();

		//  Maske für die Löcher definieren
		useMask = true;
		maskString = String::Concat ( "url(#", id, "_mask)" );

		pPolygonP->getBoundingBox ( sw, no );
		dx = no[0] - sw[0];
		dy = no[1] - sw[1];

		writer->WriteStartElement ( "mask" );
		writer->WriteAttributeString ( "maskUnits", "userSpaceOnUse" );

		STR = String::Concat ( id, "_mask" );
		writer->WriteAttributeString ( "id", STR );

		STR = XmlConvert::ToString ( sw[0] - swX );
		writer->WriteAttributeString ( "x", STR );
		STR = XmlConvert::ToString ( noY - no[1] );
		writer->WriteAttributeString ( "y", STR );
		STR = XmlConvert::ToString ( dx );
		writer->WriteAttributeString ( "width", STR );
		STR = XmlConvert::ToString ( dy );
		writer->WriteAttributeString ( "height", STR );

		writer->WriteStartElement ( "rect" );
		writer->WriteAttributeString ( "fill", "white" );

		STR = XmlConvert::ToString ( sw[0] - swX );
		writer->WriteAttributeString ( "x", STR );
		STR = XmlConvert::ToString ( noY - no[1] );
		writer->WriteAttributeString ( "y", STR );
		STR = XmlConvert::ToString ( dx );
		writer->WriteAttributeString ( "width", STR );
		STR = XmlConvert::ToString ( dy );
		writer->WriteAttributeString ( "height", STR );
		writer->WriteEndElement();

		for ( i = 0; i < pPolygonP->getLochAnz(); i++ )
		{
			STR_Number = System::Convert::ToString ( i );
			STR = String::Concat ( "#", id, "_hole_", STR_Number );

			writer->WriteStartElement ( "use" );
			writer->WriteAttributeString ( "xlink:href", STR );
			writer->WriteAttributeString ( "style", "fill:black" );
			writer->WriteEndElement();
		}

		writer->WriteEndElement();
	}
	else useMask = false;
	


	//  Verarbeitung class1 und style1
	writer->WriteStartElement ( "use" );

	STR = String::Concat ( "#", id, "_aussen" );
	writer->WriteAttributeString ( "xlink:href", STR );
	if ( class1 != NULL )
		writer->WriteAttributeString ( "class", class1 );

	if ( style1 != NULL ) STR = style1;
	else				  STR = " ";

	if ( clip1 ) STR = String::Concat ( STR, "clip-path:url(#", id, "_clip)" );
	if ( STR->CompareTo ( " ") != 0 )
		writer->WriteAttributeString ( "style", STR );

	if ( useMask ) writer->WriteAttributeString ( "mask", maskString );

	writer->WriteEndElement();

	for ( i = 0; i < pPolygonP->getLochAnz(); i++ )
	{
		STR_Number = System::Convert::ToString ( i );

		writer->WriteStartElement ( "use" );
		STR = String::Concat ( "#", id, "_hole_", STR_Number );
		writer->WriteAttributeString ( "xlink:href", STR );

		if ( class1 != NULL ) writer->WriteAttributeString ( "class", class1 );

		if ( style1 != NULL ) writer->WriteAttributeString ( "style", style1 );

		if ( useMask ) writer->WriteAttributeString ( "mask", maskString );

		writer->WriteEndElement();
	}
	if ( class2 == NULL && style2 == NULL ) return;


	//  Verarbeitung class2 und style2
	writer->WriteStartElement ( "use" );

	STR = String::Concat ( "#", id, "_aussen" );
	writer->WriteAttributeString ( "xlink:href", STR );
	if ( class2 != NULL )
		writer->WriteAttributeString ( "class", class2 );

	if ( style2 != NULL ) STR = style2;
	else				  STR = " ";

	if ( clip2 ) STR = String::Concat ( STR, "clip-path:url(#", id, "_clip)" );
	if ( STR->CompareTo ( " ") != 0 )
		writer->WriteAttributeString ( "style", STR );

	if ( useMask ) writer->WriteAttributeString ( "mask", maskString );

	writer->WriteEndElement();

	for ( i = 0; i < pPolygonP->getLochAnz(); i++ )
	{
		STR_Number = System::Convert::ToString ( i );

		writer->WriteStartElement ( "use" );
		STR = String::Concat ( "#", id, "_hole_", STR_Number );
		writer->WriteAttributeString ( "xlink:href", STR );

		if ( class2 != NULL ) writer->WriteAttributeString ( "class", class2 );

		if ( style2 != NULL ) writer->WriteAttributeString ( "style", style2 );

		if ( useMask ) writer->WriteAttributeString ( "mask", maskString );

		writer->WriteEndElement();
	}
	if ( class3 == NULL && style3 == NULL ) return;


	//  Verarbeitung class3 und style3
	writer->WriteStartElement ( "use" );

	STR = String::Concat ( "#", id, "_aussen" );
	writer->WriteAttributeString ( "xlink:href", STR );
	if ( class2 != NULL )
		writer->WriteAttributeString ( "class", class3 );

	if ( style3 != NULL ) STR = style3;
	else				  STR = " ";

	if ( clip3 ) STR = String::Concat ( STR, "clip-path:url(#", id, "_clip)" );
	if ( STR->CompareTo ( " ") != 0 )
		writer->WriteAttributeString ( "style", STR );

	if ( useMask ) writer->WriteAttributeString ( "mask", maskString );

	writer->WriteEndElement();

	for ( i = 0; i < pPolygonP->getLochAnz(); i++ )
	{
		STR_Number = System::Convert::ToString ( i );

		writer->WriteStartElement ( "use" );
		STR = String::Concat ( "#", id, "_hole_", STR_Number );
		writer->WriteAttributeString ( "xlink:href", STR );

		if ( class3 != NULL ) writer->WriteAttributeString ( "class", class3 );

		if ( style3 != NULL ) writer->WriteAttributeString ( "style", style3 );

		if ( useMask ) writer->WriteAttributeString ( "mask", maskString );

		writer->WriteEndElement();
	}
	if ( class4 == NULL && style4 == NULL ) return;


	//  Verarbeitung class4 und style4
	writer->WriteStartElement ( "use" );

	STR = String::Concat ( "#", id, "_aussen" );
	writer->WriteAttributeString ( "xlink:href", STR );
	if ( class4 != NULL )
		writer->WriteAttributeString ( "class", class4 );

	if ( style4 != NULL ) STR = style4;
	else				  STR = " ";

	if ( clip4 ) STR = String::Concat ( STR, "clip-path:url(#", id, "_clip)" );
	if ( STR->CompareTo ( " ") != 0 )
		writer->WriteAttributeString ( "style", STR );

	if ( useMask ) writer->WriteAttributeString ( "mask", maskString );

	writer->WriteEndElement();

	for ( i = 0; i < pPolygonP->getLochAnz(); i++ )
	{
		STR_Number = System::Convert::ToString ( i );

		writer->WriteStartElement ( "use" );
		STR = String::Concat ( "#", id, "_hole_", STR_Number );
		writer->WriteAttributeString ( "xlink:href", STR );

		if ( class4 != NULL ) writer->WriteAttributeString ( "class", class4 );

		if ( style4 != NULL ) writer->WriteAttributeString ( "style", style4 );

		if ( useMask ) writer->WriteAttributeString ( "mask", maskString );

		writer->WriteEndElement();
	}

}

///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writePolygon ( std::string idP, Polygon * pPolygonP, 
					String * class1, String * style1, bool clip1 )
{
	writePolygon ( idP, pPolygonP, class1, style1, clip1, NULL, NULL, false,
		           NULL, NULL, false, NULL, NULL, false );
}

///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writePolygon ( std::string idP, Polygon * pPolygonP, 
					String * class1, String * style1, bool clip1,
					String * textClass, String * annotChar, double charSize )
{
	System::String * STR;
	System::String * STR_Number;
	System::String * id;
	int              i, charAnz;
	double			 length;

	writePolygon ( idP, pPolygonP, class1, style1, clip1, NULL, NULL, false,
		           NULL, NULL, false, NULL, NULL, false );

	if ( textClass != NULL )
	{
		id = QuConvert::ToString ( idP );

		writer->WriteStartElement ( "text" );
		writer->WriteAttributeString ( "class", textClass );
		
		if ( clip1 )
		{
			STR = String::Concat ( "clip-path:url(#", id, "_clip)" );
			writer->WriteAttributeString ( "style", STR );
		}

		STR = String::Concat ( "#", id, "_aussen" );
		writer->WriteStartElement ( "textPath" );
		writer->WriteAttributeString ( "xlink:href", STR );

		length = pPolygonP->getAussenkontur()->getUmfang();
		charAnz = int ( length / charSize );

		STR = annotChar;
		for ( i = 1; i < charAnz; i++ ) STR = String::Concat ( STR, annotChar );
		writer->WriteString ( STR );

		writer->WriteEndElement();
		writer->WriteEndElement();

		for ( i = 0; i < pPolygonP->getLochAnz(); i++ )
		{
			STR_Number = System::Convert::ToString ( i );
			STR = String::Concat ( "#", id, "_hole_", STR_Number );	

			writer->WriteStartElement ( "text" );
			writer->WriteAttributeString ( "class", textClass );
			writer->WriteStartElement ( "textPath" );
			writer->WriteAttributeString ( "xlink:href", STR );

			length = pPolygonP->getLoch ( i )->getUmfang();
			charAnz = int ( length / charSize );

			STR = annotChar;
			for ( i = 1; i < charAnz; i++ ) STR = String::Concat ( STR, annotChar );
			writer->WriteString ( STR );

			writer->WriteEndElement();
			writer->WriteEndElement();
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writePolygonWithTextPath ( std::string idP, Polygon * pPolygonP, 
					String * class1, String * style1, bool clip1,
					String * textStyle, String * annotChar, double charSize )
{
	System::String * STR;
	System::String * STR_Number;
	System::String * id;
	int              i, charAnz;
	double			 length;


	writePolygon ( idP, pPolygonP, class1, style1, clip1 );

	if ( textStyle != NULL )
	{
		id = QuConvert::ToString ( idP );
		if ( clip1 )
			textStyle = String::Concat ( textStyle, ";clip-path:url(#", id, "_clip)" );

		writer->WriteStartElement ( "text" );
		writer->WriteAttributeString ( "style", textStyle );

		STR = String::Concat ( "#", id, "_aussen" );
		writer->WriteStartElement ( "textPath" );
		writer->WriteAttributeString ( "xlink:href", STR );

		length = pPolygonP->getAussenkontur()->getUmfang();
		charAnz = int ( length / charSize );

		STR = annotChar;
		for ( i = 1; i < charAnz; i++ ) STR = String::Concat ( STR, annotChar );
		writer->WriteString ( STR );

		writer->WriteEndElement();
		writer->WriteEndElement();

		for ( i = 0; i < pPolygonP->getLochAnz(); i++ )
		{
			STR_Number = System::Convert::ToString ( i );
			STR = String::Concat ( "#", id, "_hole_", STR_Number );	

			writer->WriteStartElement ( "text" );
			writer->WriteAttributeString ( "style", textStyle );
			writer->WriteStartElement ( "textPath" );
			writer->WriteAttributeString ( "xlink:href", STR );

			length = pPolygonP->getLoch ( i )->getUmfang();
			charAnz = int ( length / charSize );

			STR = annotChar;
			for ( i = 1; i < charAnz; i++ ) STR = String::Concat ( STR, annotChar );
			writer->WriteString ( STR );

			writer->WriteEndElement();
			writer->WriteEndElement();
		}
	}
}

void BPlanSVGWriter::writePolygon ( std::string idP, Polygon * pPolygonP, 
					String * class1, String * style1, bool clip1,
					String * class2, String * style2, bool clip2 )
{
	writePolygon ( idP, pPolygonP, class1, style1, clip1, class2, style2, clip2,
		           NULL, NULL, false, NULL, NULL, false );
}

void BPlanSVGWriter::writePolygon ( std::string idP, Polygon * pPolygonP, 
					String * class1, String * style1, bool clip1,
					String * class2, String * style2, bool clip2,
					String * class3, String * style3, bool clip3 )
{
	writePolygon ( idP, pPolygonP, class1, style1, clip1, class2, style2, clip2,
		           class3, style3, clip3, NULL, NULL, false );
}

///////////////////////////////////////////////////////////////////////////////
//  Rausschreiben eines Textstrings in einem Kreis							 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::drawText ( String * textStringP, double fontSizeP, double circleSizeP,
				double xPosP, double yPosP )
{
	String * STR;
	double   xSVG, ySVG;

	xSVG = xPosP - swX;
	ySVG = noY - yPosP;

	writer->WriteStartElement ( "text" );

	STR = XmlConvert::ToString ( xSVG );
	writer->WriteAttributeString ( "x", STR );

	STR = XmlConvert::ToString ( ySVG );
	writer->WriteAttributeString ( "y", STR );

	writer->WriteAttributeString ( "text-anchor", "middle" );

	STR = XmlConvert::ToString ( fontSizeP );
	writer->WriteAttributeString ( "font-size", STR );

	writer->WriteString ( textStringP );
	writer->WriteEndElement();

	if ( circleSizeP > 0 )
	{
		writer->WriteStartElement ( "circle" );

		STR = XmlConvert::ToString ( xSVG );
		writer->WriteAttributeString ( "cx", STR );

		STR = XmlConvert::ToString ( ySVG );
		writer->WriteAttributeString ( "cy", STR );

		STR = XmlConvert::ToString ( circleSizeP );
		writer->WriteAttributeString ( "r", STR );

		writer->WriteAttributeString ( "fill", "none" );
		writer->WriteAttributeString ( "stroke", "black" );
		writer->WriteAttributeString ( "stroke-width", "1.0" );

		writer->WriteEndElement();
	}

}

///////////////////////////////////////////////////////////////////////////////
//  Rausschreiben eines Symbols							 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::drawSymbol ( String * symbolIdP, double xPosP, double yPosP, double angle )
{
	String * STR;
	double   xSVG, ySVG;

	xSVG = xPosP - swX;
	ySVG = noY - yPosP;

	writer->WriteStartElement ( "use" );

	STR = String::Concat ( svgDefinesDatei, "#", symbolIdP );
	writer->WriteAttributeString ( "xlink:href" , STR );

	angle = -(angle*180.0)/PI;
	STR = String::Concat ( "translate(", XmlConvert::ToString(xSVG), ", ");
	STR = String::Concat ( STR, XmlConvert::ToString(ySVG), ")," );
	STR = String::Concat ( STR, "rotate(", XmlConvert::ToString (angle), ")" );
	writer->WriteAttributeString ( "transform", STR );

	writer->WriteEndElement();
}




///////////////////////////////////////////////////////////////////////////////
//  Rausschreiben einer Curve												 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeCurve ( std::string idP, Curve * pCurveP, String * class1 )
{
	System::String * STR;
	System::String * id;
	System::String * pathString;
	string			 stdString;

	id = QuConvert::ToString ( idP );

	stdString = pCurveP->getPointsSVG ( swX, noY );
	pathString = QuConvert::ToString ( stdString );

	writer->WriteStartElement ( "path" );
	STR = String::Concat ( id, "_path" );
	writer->WriteAttributeString ( "id", STR );
	writer->WriteAttributeString ( "d", pathString );
	writer->WriteAttributeString ( "class", class1 );
	writer->WriteEndElement();
}

void BPlanSVGWriter::writeCurve ( std::string idP, Curve * pCurveP, String * class1, String * class2 )
{
	System::String * STR;
	System::String * id;
	System::String * pathString;
	string			 stdString;

	id = QuConvert::ToString ( idP );

	stdString = pCurveP->getPointsSVG ( swX, noY );
	pathString = QuConvert::ToString ( stdString );

	writer->WriteStartElement ( "path" );
	STR = String::Concat ( id, "_path_A" );
	writer->WriteAttributeString ( "id", STR );
	writer->WriteAttributeString ( "d", pathString );
	writer->WriteAttributeString ( "class", class1 );
	writer->WriteEndElement();

	writer->WriteStartElement ( "path" );
	STR = String::Concat ( id, "_path_B" );
	writer->WriteAttributeString ( "id", STR );
	writer->WriteAttributeString ( "d", pathString );
	writer->WriteAttributeString ( "class", class2 );
	writer->WriteEndElement();
}



///////////////////////////////////////////////////////////////////////////////
//  RaeumlicherGeltungsbereich												 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeRaeumlicherGeltungsbereich ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, 
		"RaeumlicherGeltungsbereich-aussen", NULL, false,
		"RaeumlicherGeltungsbereich-aussen1", NULL, true );
}

///////////////////////////////////////////////////////////////////////////////
//  RaeumlicherGeltungsbereich												 //
///////////////////////////////////////////////////////////////////////////////
/*
void BPlanSVGWriter::writeSchutzPflegeEntwicklungsFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, 
		"SchutzPflegeEntwicklungsFlaeche-unten", NULL, true,
		"SchutzPflegeEntwicklungsFlaeche-mitte", NULL, true,
		"SchutzPflegeEntwicklungsFlaeche-oben", NULL, true,
		"SchutzPflegeEntwicklungsFlaeche-aussen", NULL, false );
}
*/
///////////////////////////////////////////////////////////////////////////////
//  RaeumlicherGeltungsbereich												 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeBaugebietsFlaechenTeil ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	bool success;
	string attributWert;
	String * colorString;
	String * styleString;
	String * STR;
	double x, y, sw[2], no[2];
	double fontSize = 10;
	double circleSize = 0;

	success = pPlanObjektP->getStringAttributWert ( "artDerBaulichenNutzung", attributWert );

	if ( success )
	{
		if ( attributWert == "Kleinsiedlungsgebiet" ||
			 attributWert == "ReinesWohngebiet" ||
			 attributWert == "AllgWohngebiet" ||
			 attributWert == "BesonderesWohngebiet" )
		{
			    colorString = "rgb(255,138,111);";

				if ( attributWert == "Kleinsiedlungsgebiet" ) STR = "WS";
				else
				if ( attributWert == "ReinesWohngebiet" ) STR = "WR";
				else
				if ( attributWert == "AllgWohngebiet" ) STR = "WA";
				else
				if ( attributWert == "BesonderesWohngebiet" ) STR = "WB";
		}

		else

		if ( attributWert == "Dorfgebiet" ||
			 attributWert == "Mischgebiet" ||
			 attributWert == "Kerngebiet" )
		{
			    colorString = "rgb(168,112,0);";
				if ( attributWert == "Dorfgebiet" ) STR = "MD";
				else
				if ( attributWert == "Mischgebiet" ) STR = "MI";
				else
				if ( attributWert == "Kerngebiet" ) STR = "MK";
		}

		else

		if ( attributWert == "Gewerbegebiet" ||
			 attributWert == "Industriegebiet" )
		{
			    colorString = "rgb(192, 192, 192);";
				if ( attributWert == "Gewerbegebiet" ) STR = "GE";
				else
				if ( attributWert == "Industriegebiet" ) STR = "GI";
		}
		else
			    colorString = "rgb(228,92,0);";
	}
	else
	{
		colorString = "rgb(255,255,255);";
		STR = "";
	}

	styleString = String::Concat ( "fill: ", colorString, "stroke: black; ", "stroke-width: 1;" );

	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, 
		"BaugebietFlaechenTeil", styleString, true,
		NULL, NULL, true,
		NULL, NULL, true,
		NULL, NULL, false );

	pPolyP->getBoundingBox ( sw, no );
	x = 0.5*(sw[0] + no[0] );
	y = 0.5*(sw[1] + no[1] );
	drawText ( STR, fontSize, circleSize, x, y );
}

///////////////////////////////////////////////////////////////////////////////
//  KennzeichnungsFläche													 //
///////////////////////////////////////////////////////////////////////////////

void BPlanSVGWriter::writeKennzeichnungsFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	double charSize = 2.0;

	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, 
		"KennzeichnungLinie", NULL, true,
		"KennzeichnungTextSignatur", "x", charSize );
}

///////////////////////////////////////////////////////////////////////////////
//  FoerderungsFlaeche														 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeFoerderungsFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, 
		"FoerderungLinie", NULL, true,
		"FoerderungTextSignatur","F", 2.0 );
}

///////////////////////////////////////////////////////////////////////////////
//  PersGruppenBestimmteFlaeche														 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writePersGruppenBestimmteFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, 
		"PersGruppenBestimmteFlaecheLinie", NULL, true,
		"PersGruppenBestimmteFlaecheTextSignatur","P", 2.0 );
}

///////////////////////////////////////////////////////////////////////////////
//  TechikBestimmteFlaeche													 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeTechnikBestimmteFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, 
		"TechnikBestimmteFlaecheLinie", NULL, true,
		"TechnikBestimmteFlaecheTextSignatur","T", 2.0 );
}

///////////////////////////////////////////////////////////////////////////////
//  FlaecheMitBesonderemNutzungszweck										 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeFlaecheMitBesonderemNutzungszweck ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, 
		"FlaecheMitBesonderemNutzungszweck", NULL, false );
}

///////////////////////////////////////////////////////////////////////////////
//  FlaecheMitBesonderemNutzungszweck										 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeUeberbaubareGrundstuecksflaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, 
		"UeberbaubareGrundstuecksflaeche", NULL, false );
}

///////////////////////////////////////////////////////////////////////////////
//  AbgrabungsFlaeche														 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeAbgrabungsFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, 
		"AbgrabungLinie", NULL, false,
		"AbgrabungText", System::Convert::ToString ( __wchar_t (0x25B2) ), 2.0 );
}

///////////////////////////////////////////////////////////////////////////////
//  BodenschaetzeFlaeche													 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeBodenschaetzeFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, 
		"BodenschaetzeLinie", NULL, false,
		"BodenschaetzeText", System::Convert::ToString ( __wchar_t (0x25B2) ), 2.0 );
}

///////////////////////////////////////////////////////////////////////////////
//  AbgrabungsFlaeche														 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeAufschuettungsFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, 
		"AufschuettungLinie", NULL, true,
		"AufschuettungText", System::Convert::ToString ( __wchar_t (0x25B2) ), 2.0 );
}

///////////////////////////////////////////////////////////////////////////////
//  GemeinbedarfFlaeche														 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeGemeinbedarfsFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, 
		"GemeinbedarfFlaeche", NULL, false );
}

///////////////////////////////////////////////////////////////////////////////
//  SpielSportanlagenFlaeche												 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeSpielSportanlagenFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, 
		"SpielSportanlagenFlaecheF", NULL, true,
		"SpielSportanlagenFlaecheText", System::Convert::ToString ( __wchar_t (0x003A) ), 0.5 );

}

///////////////////////////////////////////////////////////////////////////////
//  LandwirtschaftsFlaeche														 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeLandwirtschaftsFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, "LandwirtschaftsFlaeche", NULL, true );
}

///////////////////////////////////////////////////////////////////////////////
//  WaldFlaeche														 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeWaldFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, "WaldFlaeche", NULL, true );
}

///////////////////////////////////////////////////////////////////////////////
//  GruenFlaeche														 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeGruenFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	String * STR;
	string   stdString;
	bool	 success;

	success = pPlanObjektP->getStringAttributWert ( "zweckbestimmung", stdString );

	if ( success )
	{
		if ( stdString == "Parkanlage" )
		{
			STR = String::Concat ( "fill: url(", svgDefinesDatei, "#pattern_Parkanlage);" );
			writePolygon ( pPlanObjektP->getGmlId(), pPolyP, "GruenFlaeche", STR, true );
		}
		else
		if ( stdString == "Friedhof" )
		{
			STR = String::Concat ( "fill: url(", svgDefinesDatei, "#pattern_Friedhof);" );
			writePolygon ( pPlanObjektP->getGmlId(), pPolyP, "GruenFlaeche", STR, true );
		}
		else
			writePolygon ( pPlanObjektP->getGmlId(), pPolyP, "GruenFlaeche", NULL, true );
	}
	else
		writePolygon ( pPlanObjektP->getGmlId(), pPolyP, "GruenFlaeche", NULL, true );
}

///////////////////////////////////////////////////////////////////////////////
//  AnpflanzungBindungErhaltungsFlaeche														 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeAnpflanzungBindungErhaltungsFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	String * STR;
	string   stdString;
	bool	 success;

	success = pPlanObjektP->getStringAttributWert ( "zweckbestimmung", stdString );

	if ( success )
	{
		if ( stdString == "Anpflanzung" )
			writePolygon ( pPlanObjektP->getGmlId(), pPolyP, 
				"AnpflanzungLinie", NULL, true,
				"AnpflanzungTextSignatur", System::Convert::ToString ( __wchar_t (0x25CB) ), 2.0 );
		else
		if ( stdString == "Erhaltung" || stdString == "Bindung" )
			writePolygon ( pPlanObjektP->getGmlId(), pPolyP, 
				"ErhaltungLinie", NULL, true,
				"ErhaltungTextSignatur", System::Convert::ToString ( __wchar_t (0x25CF) ), 2.0 );
	}
	else
		writePolygon ( pPlanObjektP->getGmlId(), pPolyP, 
			"ErhaltungLinie", NULL, true,
			"ErhaltungTextSignatur", System::Convert::ToString ( __wchar_t (0x25CF) ), 2.0 );
}

///////////////////////////////////////////////////////////////////////////////
//  SchutzgebietFlaeche														 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeSchutzgebietFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, "SchutzgebietFlaecheA", NULL, true,
						 "SchutzgebietFlaecheB", NULL, true,
						 "SchutzgebietFlaecheC", NULL, true );

}
///////////////////////////////////////////////////////////////////////////////
//  SchutzPflegeEntwicklungsFlaeche											 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeSchutzPflegeEntwicklungsFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, "SchutzPflegeEntwicklungsFlaecheA", NULL, true,
						 "SchutzPflegeEntwicklungsFlaecheB", NULL, true,
						 "SchutzPflegeEntwicklungsFlaecheC", NULL, true,
						 "SchutzPflegeEntwicklungsFlaecheD", NULL, true );

}
///////////////////////////////////////////////////////////////////////////////
//  Erhaltungsbereich														 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeErhaltungsbereich ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, "ErhaltungsbereichA", NULL, true,
						 "ErhaltungsbereichB", NULL, true,
						 "ErhaltungsbereichC", NULL, true,
						 "ErhaltungsbereichD", NULL, true );

}

///////////////////////////////////////////////////////////////////////////////
//  DenkmalschutzBereich													 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeDenkmalschutzBereich ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, "DenkmalschutzA", NULL, true,
						 "DenkmalschutzB", NULL, true,
						 "DenkmalschutzC", NULL, true,
						 "DenkmalschutzD", NULL, true );

}
///////////////////////////////////////////////////////////////////////////////
//  SchutzPflegeEntwicklungsFlaeche											 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeDenkmalschutzEnsemble ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, "DenkmalschutzA", NULL, true,
						 "DenkmalschutzB", NULL, true,
						 "DenkmalschutzC", NULL, true,
						 "DenkmalschutzD", NULL, true );

}

///////////////////////////////////////////////////////////////////////////////
//  VerEntsorgungsFlaeche													 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeVerEntsorgungsFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	bool success, flaechenschluss;

	success = pPlanObjektP->getBoolAttributWert ( "flaechzenschluss", flaechenschluss );
	if ( !success ) flaechenschluss = false;

	if ( flaechenschluss )
		writePolygon ( pPlanObjektP->getGmlId(), pPolyP, "VerEntsorgungFlaeche", NULL, true );
	else
		writePolygon ( pPlanObjektP->getGmlId(), pPolyP, "VerEntsorgungRandsignaturA", NULL, true,
						 "VerEntsorgungRandsignaturB", NULL, true );

}


///////////////////////////////////////////////////////////////////////////////
// LuftverkehrFlaeche														 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeLuftverkehrFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, "LuftverkehrFlaecheA", NULL, true,
					 "LuftverkehrFlaecheB", NULL, true );

}

///////////////////////////////////////////////////////////////////////////////
// BahnFlaeche																 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeBahnFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, "BahnFlaecheA", NULL, false );
}


///////////////////////////////////////////////////////////////////////////////
// VerkehrsFlaeche															 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeVerkehrsFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, "VerkehrsFlaecheA", NULL, true );
}

///////////////////////////////////////////////////////////////////////////////
// VerkehrsFlaeche															 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeVerkehrsFlaecheBesondererZweckbestimmung ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	String * STR;

	STR = String::Concat ( "fill: url(", svgDefinesDatei, "#pattern_VerksflBesondZweckbest);" );
//	STR = "fill: url(defines.svg#pattern_VerksflBesondZweckbest);";
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, "VerkehrsFlaecheBesondererZweckbestimmungA", STR, true );
}

///////////////////////////////////////////////////////////////////////////////
// WasserFlaeche															 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeWasserFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, "WasserFlaecheA", NULL, true );
}

///////////////////////////////////////////////////////////////////////////////
//  WasserwirtschaftsFlaeche												 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeWasserwirtschaftsFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	System::String * STR;

	STR = "font-family: MyFonts; fill: rgb(0,123,206)";
	writePolygonWithTextPath ( pPlanObjektP->getGmlId(), pPolyP, 
		"WasserwirtschaftLinie", NULL, true, STR, "A", 2.0 );
}

///////////////////////////////////////////////////////////////////////////////
// WasserrechtsFlaeche														 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeWasserrechtsFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, "WasserrechtsFlaecheA", NULL, true,
					 "WasserrechtsFlaecheB", NULL, true );

}

///////////////////////////////////////////////////////////////////////////////
// WasserrechtsFlaeche														 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeVorbHochwSchutzFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, "WasserrechtsFlaecheA", NULL, true,
					 "WasserrechtsFlaecheB", NULL, true );

}

///////////////////////////////////////////////////////////////////////////////
//  ImmissionsschutzFlaeche													 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeImmissionsschutzFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	System::String * STR;

	STR = "font-family: MyFonts; fill: black";
	writePolygonWithTextPath ( pPlanObjektP->getGmlId(), pPolyP, 
		"ImmissionsschutzLinie", NULL, true, STR, "B", 2.0 );
}


///////////////////////////////////////////////////////////////////////////////
//  LuftreinhalteFlaeche													 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeLuftreinhalteFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	System::String * STR;

	STR = "font-family: MyFonts; fill: black";
	writePolygonWithTextPath ( pPlanObjektP->getGmlId(), pPolyP, 
		"LuftreinhalteLinie", NULL, true, STR, "C", 2.0 );
}


///////////////////////////////////////////////////////////////////////////////
//  FreiFlaeche																 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeFreiFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	System::String * STR;

	STR = "font-family: MyFonts; fill: black";
	writePolygonWithTextPath ( pPlanObjektP->getGmlId(), pPolyP, 
		"FreiflaecheLinie", NULL, true, STR, "D", 2.0 );
}


///////////////////////////////////////////////////////////////////////////////
//  WegerechteBelasteteteFlaeche													 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeWegerechteBelasteteFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, 
		"WegerechteBelasteteFlaeche", NULL, true );
}


///////////////////////////////////////////////////////////////////////////////
//  NebenanlagenFlaeche														 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeNebenanlagenFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, "NebenanlagenFlaeche", NULL, true );
}


///////////////////////////////////////////////////////////////////////////////
//  GemeinschaftsanlagenFlaeche												 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeGemeinschaftsanlagenFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, "GemeinschaftsanlagenFlaeche", NULL, true );
}


///////////////////////////////////////////////////////////////////////////////
//  FlaecheAllgemein														 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeFlaecheAllgemein ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, "FlaecheAllgemein", NULL, true );
}


///////////////////////////////////////////////////////////////////////////////
//  Stuetzmauer																 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeStrassenkoerper ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, "Stuetzmauer", NULL, true );
}

///////////////////////////////////////////////////////////////////////////////
//  AusgleichsFlaeche																 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeAusgleichsFlaeche ( PlanFlaechenObjekt * pPlanObjektP, Polygon * pPolyP )
{
	writePolygon ( pPlanObjektP->getGmlId(), pPolyP, "AusgleichsFlaeche", NULL, true );
}

///////////////////////////////////////////////////////////////////////////////
//  Baulinie																 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeBaulinie ( PlanLinienObjekt * pObjP, Curve * pCurveP )
{
	writeCurve ( pObjP->getGmlId(), pCurveP, "Baulinie" );
}
///////////////////////////////////////////////////////////////////////////////
//  Baugrenze																 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeBaugrenze ( PlanLinienObjekt * pObjP, Curve * pCurveP )
{
	writeCurve ( pObjP->getGmlId(), pCurveP, "Baugrenze" );

}
///////////////////////////////////////////////////////////////////////////////
//  FirstRichtung															 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeFirstRichtung ( PlanLinienObjekt * pObjP, Curve * pCurveP )
{
	writeCurve ( pObjP->getGmlId(), pCurveP, "FirstRichtung" );
}
///////////////////////////////////////////////////////////////////////////////
//  PflanzungLinienfoermig													 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeAnpflanzungBindungErhaltungsLinie ( PlanLinienObjekt * pObjP, Curve * pCurveP )
{
	vector<double> xCoord, yCoord, vAngles;
	string		   attributWert;
	string		   pflanzenTyp;
	bool		   Anpflanzung, success;
	double		   scanDist = 30.0;
	double		   x, y, angle;
	int			   i, anz;

	anz = pCurveP->scanCurve ( xCoord, yCoord, vAngles, scanDist );

	success = pObjP->getStringAttributWert ( "massnahme", attributWert );
	if ( success )
	{
		if ( attributWert == "Anpflanzung" ) Anpflanzung = true;
		else						         Anpflanzung = false;
	}
	else Anpflanzung = true;

	success = pObjP->getStringAttributWert ( "gegenstand", pflanzenTyp );
	if ( !success ) pflanzenTyp = "SonstBepflanzung";


	for ( i = 0; i < anz; i++ )
	{
		x     = xCoord[i];
		y     = yCoord[i];
		angle = vAngles[i];

		if ( Anpflanzung )
		{
			if ( pflanzenTyp == "Baeume" )
				drawSymbol ( "Anpflanzung_Baeume", x, y, angle );
			else
			if ( pflanzenTyp == "Straeucher" )
				drawSymbol ( "Anpflanzung_Straeucher", x, y, angle );
			else
				drawSymbol ( "Anpflanzung_Sonstige", x, y, angle );
		}
		else
		{
			if ( pflanzenTyp == "Baeume" )
				drawSymbol ( "Erhaltung_Baeume", x, y, angle );
			else
			if ( pflanzenTyp == "Straeucher" )
				drawSymbol ( "Erhaltung_Straeucher", x, y, angle );
			else
				drawSymbol ( "Erhaltung_Sonstige", x, y, angle );
		}
	}
}
///////////////////////////////////////////////////////////////////////////////
//  StuetzmauerLinie														 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeStrassenkoerperLinie ( PlanLinienObjekt * pObjP, Curve * pCurveP )
{
	vector<double> xCoord, yCoord, vAngles;
	double		   scanDist = 5.0;
	double		   x, y, angle;
	int			   i, anz;

	writeCurve ( pObjP->getGmlId(), pCurveP, "StuetzmauerLinieA", "StuetzmauerLinieB" );

	anz = pCurveP->scanCurve ( xCoord, yCoord, vAngles, scanDist );

	for ( i = 0; i < anz; i++ )
	{
		x     = xCoord[i];
		y     = yCoord[i];
		angle = vAngles[i];

		drawSymbol ( "Stuetzmauer", x, y, angle );
	}
}
///////////////////////////////////////////////////////////////////////////////
//  LinieAllgemein															 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeLinieAllgemein ( PlanLinienObjekt * pObjP, Curve * pCurveP )
{
	writeCurve ( pObjP->getGmlId(), pCurveP, "LinieAllgemein" );
}
///////////////////////////////////////////////////////////////////////////////
//  VerEntsorgungsleitung													 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeVerEntsorgungsleitung ( PlanLinienObjekt * pObjP, Curve * pCurveP )
{
	vector<double> xCoord, yCoord, vAngles;
	double		   x, y, angle;
	float          scanDist = 30;
	int			   i, anz;
	string		   attributWert;
	bool		   success, unterirdisch;

	writeCurve ( pObjP->getGmlId(), pCurveP, "VerEntsorgungsLeitung" );

	anz = pCurveP->scanCurve ( xCoord, yCoord, vAngles, scanDist );

	success = pObjP->getStringAttributWert ( "unterirdisch", attributWert );
	if ( success )
	{
		if ( attributWert == "true" ) unterirdisch = true;
		else						  unterirdisch = false;
	}
	else unterirdisch = false;

	for ( i = 0; i < anz; i++ )
	{
		x     = xCoord[i];
		y     = yCoord[i];
		angle = vAngles[i];

		if ( unterirdisch )
			drawSymbol ( "VerEntsorgungLeitungUnterirdisch", x, y, angle );
		else
			drawSymbol ( "VerEntsorgungLeitungOberirdisch", x, y, angle );
	}
}

///////////////////////////////////////////////////////////////////////////////
//  Strassenbegrenzungslinie												 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeStrassenbegrenzungslinie ( PlanLinienObjekt * pObjP, Curve * pCurveP )
{
	writeCurve ( pObjP->getGmlId(), pCurveP, "StrassenbegrenzungsLinie" );
}
///////////////////////////////////////////////////////////////////////////////
//  BahnLinie																 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeBahnLinie ( PlanLinienObjekt * pObjP, Curve * pCurveP )
{
	vector<double> xCoord, yCoord, vAngles;
	double		   x, y, angle;
	float          scanDist = 30;
	int			   i, anz;
	string		   attributWert;
	bool		   success;

	writeCurve ( pObjP->getGmlId(), pCurveP, "Bahnlinie" );

	anz = pCurveP->scanCurve ( xCoord, yCoord, vAngles, scanDist );

	success = pObjP->getStringAttributWert ( "zweckbestimmung", attributWert );
	if ( !success ) attributWert = "Strassenbahn";

	for ( i = 0; i < anz; i++ )
	{
		x     = xCoord[i];
		y     = yCoord[i];
		angle = vAngles[i];

		if ( attributWert == "Strassenbahn"  )
			drawSymbol ( "Strassenbahn", x, y, angle );
		else
			drawSymbol ( "Seilbahn", x, y, angle );
	}}
///////////////////////////////////////////////////////////////////////////////
//  Einfahrtsbereich														 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeEinfahrtsbereich ( PlanLinienObjekt * pObjP, Curve * pCurveP )
{
	GeoPoint		 * p;
	CurveSegment * pSeg;
	double		   steigung;
	int			   anz;

	writeCurve ( pObjP->getGmlId(), pCurveP, "Einfahrtsbereich" );

	anz = pCurveP->getCurveSegmentAnz();
	if ( anz == 0 ) return;

	pSeg = pCurveP->getCurveSegment ( 0 ); 
	p = pSeg->getAnfangsPunkt();
	steigung = pSeg->getAnfangsSteigung();
	drawSymbol ( "Einfahrt", p->getX(), p->getY(), steigung );

	pSeg = pCurveP->getCurveSegment ( anz-1 ); 
	p = pSeg->getEndPunkt();
	steigung = pSeg->getEndSteigung();
	drawSymbol ( "Einfahrt", p->getX(), p->getY(), steigung );
}

///////////////////////////////////////////////////////////////////////////////
//  BereichOhneEinAusfahrt													 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeBereichOhneEinAusfahrt ( PlanLinienObjekt * pObjP, Curve * pCurveP )
{

}

///////////////////////////////////////////////////////////////////////////////
//  PflanzungPunktfoermig													 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeAnpflanzungBindungErhaltungsMassnahme ( PlanPunktObjekt * pPlanObjektP, GeoPoint * pPoint )
{
	string attributWert;
	string pflanzenTyp;
	bool   Anpflanzung, success;
	double x, y, angle;

	x     = pPoint->getX();
	y	  = pPoint->getY();
	angle = 0.0;

	success = pPlanObjektP->getStringAttributWert ( "massnahme", attributWert );
	if ( success )
	{
		if ( attributWert == "Anpflanzung" ) Anpflanzung = true;
		else						       Anpflanzung = false;
	}
	else Anpflanzung = false;

	success = pPlanObjektP->getStringAttributWert ( "gegenstand", pflanzenTyp );
	if ( !success ) pflanzenTyp = "SonstBepflanzung";

	if ( Anpflanzung )
	{
		if ( pflanzenTyp == "Baeume" )
			drawSymbol ( "Anpflanzung_Baeume", pPoint->getX(), y, angle );
		else
		if ( pflanzenTyp == "Straeucher" )
			drawSymbol ( "Anpflanzung_Straeucher", x, y, angle );
		else
			drawSymbol ( "Anpflanzung_Sonstige", x, y, angle );
	}
	else
	{
		if ( pflanzenTyp == "Baeume" )
			drawSymbol ( "Erhaltung_Baeume", x, y, angle );
		else
		if ( pflanzenTyp == "Straeucher" )
			drawSymbol ( "Erhaltung_Straeucher", x, y, angle );
		else
			drawSymbol ( "Erhaltung_Sonstige", x, y, angle );
	}


}
///////////////////////////////////////////////////////////////////////////////
//  AusgleichsMassnahme														 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeAusgleichsMassnahme (  PlanPunktObjekt * pPlanObjektP, GeoPoint * pPoint )
{
	double x, y, angle;

	x     = pPoint->getX();
	y	  = pPoint->getY();
	angle = 0.0;

	drawSymbol ( "AusgleichsMassnahme", x, y, angle );
}
///////////////////////////////////////////////////////////////////////////////
//  HoehenObjekt															 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeHoehenObjekt (  PlanPunktObjekt * pPlanObjektP, GeoPoint * pPoint )
{
	double x, y, angle, fontSize, hoehe;
	bool   success;

	x        = pPoint->getX();
	y	     = pPoint->getY();
	angle    = 0.0;
	fontSize = 14.0;

	success = pPlanObjektP->getDoubleAttributWert  ( "hoehe", hoehe );
	if ( !success ) return;


	drawText ( Convert::ToString ( hoehe ), fontSize, 0.0, x, y );
}
///////////////////////////////////////////////////////////////////////////////
//  PunktAllgemein															 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writePunktAllgemein (  PlanPunktObjekt * pPlanObjektP, GeoPoint * pPoint )
{
	double x, y, angle;

	x     = pPoint->getX();
	y	  = pPoint->getY();
	angle = 0.0;

	drawSymbol ( "PunktAllgemein", x, y, angle );
}
///////////////////////////////////////////////////////////////////////////////
//  DenkmalschutzEinzelanlage												 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeDenkmalschutzEinzelanlage (  PlanPunktObjekt * pPlanObjektP, GeoPoint * pPoint )
{
	double x, y, angle, fontSize;

	x        = pPoint->getX();
	y	     = pPoint->getY();
	angle    = 0.0;
	fontSize = 12;

	drawText ( "D", fontSize, 0.0, x, y );
	drawSymbol ( "DenkmalschutzEinzelanlage", x, y, angle );
}
///////////////////////////////////////////////////////////////////////////////
//  Einfahrt																 //
///////////////////////////////////////////////////////////////////////////////
void BPlanSVGWriter::writeEinfahrt (  PlanPunktObjekt * pPlanObjektP, GeoPoint * pPoint )
{
	double x, y, angle;

	x        = pPoint->getX();
	y	     = pPoint->getY();
	angle    = 0.0;

	drawSymbol ( "Einfahrt", x, y, angle );
}

